---
title: DBScan
date: 2018-09-23 18:37:27
tags: [机器学习, 算法]
mathjax: true
categories: 机器学习
---

## 基于密度的方法(Density-based methods)
### 基本思想
基于密度的方法：k-means解决不了不规则形状的聚类。于是就有了Density-based methods来系统解决这个问题。该方法同时也对噪声数据的处理比较好。其原理简单说画圈儿，其中要定义两个参数，一个是圈儿的最大半径，一个是一个圈儿里最少应容纳几个点。只要邻近区域的密度（对象或数据点的数目）超过某个阈值，就继续聚类,最后在一个圈里的，就是一个类[^各种聚类算法]。DBSCAN（Density-Based Spatial Clustering of Applications with Noise）[^dbscan论文]就是其中的典型.

### DBSCAN密度定义[^刘建平博客]
DBSCAN是基于一组邻域来描述样本集的紧密程度的，参数($\epsilon$, MinPts)用来描述邻域的样本分布紧密程度。其中，$\epsilon$描述了某一样本的邻域距离阈值 *（即以该样本为圆心的超球半径）*，MinPts描述了某一样本的距离为ϵ的邻域中样本个数的阈值*（即落在该超球体内的样本点个数）*。
 
假设我的样本集是$D=(x_1,x_2,...,x_m)$,则DBSCAN具体的密度描述定义如下：
 - **$\epsilon$-邻域：**对于$x_j \in D$，其$\epsilon$-邻域包含样本集$D$中与$x_j$的距离不大于$\epsilon$的子样本，即$N_{\epsilon}(x_j)=\{ x_i \in D|distance(x_i, x_j) \leq \epsilon\}$，这个子样本集的个数记为$|N_{\epsilon}(x_j)|$。***以$x_j$为中心，以$\epsilon$为半径的超球体即为$\epsilon$-邻域***
 - **核心对象：**对于任一样本$x_j \in D$，如果其$\epsilon$-邻域对应的$N_{\epsilon}(x_j)$至少包含MinPts个样本，即如果$|N_{\epsilon}(x_j)| \leq MinPts$，则$x_j$是核心对象。***满足阈值门限的超球体中心为核心对象***

 - **密度直达：**如果$x_i$位于$x_j$的$\epsilon$-邻域中，且$x_j$是核心对象，则称$x_i$由$x_j$密度直达。注意反之不一定成立，即此时不能说$x_j$由$x_i$密度直达, 除非且$x_i$也是核心对象。***被包含在以$x_j$为中心的超球体中所有实例点都是由$x_j$密度直达***

 - **密度可达：**对于$x_i$和$x_j$,如果存在样本样本序列$p_1,p_2,...,p_T$,满足$p_1=x_i,p_T=x_j$, 且$p_{t+1}$由$p_t$密度直达，则称$x_j$由$x_i$密度可达。也就是说，***密度可达满足传递性***。此时序列中的传递样本$p_1,p_2,...,p_{T-1}$均为核心对象，因为只有核心对象才能使其他样本密度直达。注意密度可达也不满足对称性，这个可以由密度直达的不对称性得出。

 - **密度相连：**对于$x_i$和$x_j$,如果存在核心对象样本$x_k$，使$x_i$和$x_j$均由$x_k$密度可达，则称$x_i$和$x_j$密度相连。注意密度相连关系是满足对称性的。

从下图可以很容易看出理解上述定义，图中$MinPts=5$，红色的点都是核心对象，因为其$\epsilon$-邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的$\epsilon$-邻域内所有的样本相互都是密度相连的。
![密度定义实例](https://upload-images.jianshu.io/upload_images/2268630-a41e2aff0b0018c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### DBSCAN密度聚类思想
DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。

这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的$\epsilon$-邻域里；如果有多个核心对象，则簇里的任意一个核心对象的$\epsilon$-邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的$\epsilon$-邻域里所有的样本的集合组成的一个DBSCAN聚类簇。

那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。

基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。

第一个是一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，在DBSCAN中，我们一般将这些样本点标记为噪音点。

第二个是距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和KNN分类算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用KD树或者球树来快速的搜索最近邻。

第三种问题比较特殊，某些样本$x_a$可能到两个核心$x_b, x_c$对象的距离都小于$\epsilon$，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？一般来说，此时DBSCAN采用先来后到，先进行聚类的类别簇会标记这个样本为它的类别。也就是说BDSCAN的算法不是完全稳定的算法。***此时$x_a$为非核心对象，且处于两个簇（$x_b$所在簇和$x_c$所在簇）的边缘，如上图中两个簇的交汇处的点***

### DBSCAN小结
和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它**最大的优势是可以发现任意形状的聚类簇**，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。

那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。***（如何判定数据集是稠密的？）***

下面对DBSCAN算法的优缺点做一个总结。
 - DBSCAN的主要优点有：
   1. 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。
    2. 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。
    3. 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。***（如何理解聚类结果没有偏倚，在实际应用中如何体现）***

 - DBSCAN的主要缺点有：
    1. 如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。***(如何判定样本集的密度不均匀？聚类间距相差大如何理解？)***
    2. 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。
    3. 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值$\epsilon$，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。


[^各种聚类算法]: [各种聚类算法的系统介绍和比较](https://blog.csdn.net/abc200941410128/article/details/78541273)
[^dbscan论文]: [Density-Based Spatial Clustering of Applications with Noise](https://www.aaai.org/Papers/KDD/1996/KDD96-037.pdf)
[^刘建平博客]: [DBSCAN密度聚类算法详解](https://www.cnblogs.com/pinard/p/6208966.html)
